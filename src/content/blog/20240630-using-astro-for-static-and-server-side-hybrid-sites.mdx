---
title: Using Astro for Static & Server Side Hybrid Sites
description: Creating static websites through Astro web framework
pubDate: 2024-06-30
author: Jackson Lloyd
heroImage: /blog-placeholder-1.jpg
category: web development
subCategory: frameworks
tags:
  - astro
  - blog
  - frontend
  - web-development
---
## Contents

[Astro](https://astro.build) is another JavaScript (JS) web framework for creating incredibly fast, sites.
Astro is opinionated to optimise speed and improved SEO (Search Engine Optimisation) rating.
It does this by rendering components server side, minimising client side JS required for the site as possible and improving the SEO by sending HTML before sending required JavaScript, if any. I've talked about the performance gains from a hybrid of client side and server side rendering before in a previous blog post [The Fall & Resurgence of Server Side](../20240202-the-fall-and-resurgence-of-server-side).

Astro allows you to plugin and use any major UI framework such as React, Vue, Preact, Svelte and SolidJs.
These frameworks are an opt-in integrations, which you install and add into Astro config, this integrations will use the specific framework's renderer to create elements. Then taking the HTML output and passing it to Astro to render, this allows any choice of frontend frameworks, which Astro has integrations built for. Lastly, any client side JS can be sent down to the client browser explicitly, this also follows an opt-in approach to prevent excessive JS being sent to the browser taking longer for the site to load, but all the JS will be deferred from being sent until the static content (HTML and CSS) has been sent and painted.

## Components & Syntax

Astro components are written using [Markdown frontmatter](https://frontmatter.codes/docs/markdown) to fence (`---`) off server side javascript, Component Script, and the HTML + JS Expressions component, Component Template:

```astro
---
// Component Script (JS)
---
<!-- Component Template (HTML + JS Expressions) -->
```

If you have server side rendering or hybrid output set, means you can use server side JavaScript to call external resources with secrets, then send down the rendered HTML to the client, like so: 

```js:astro.config.mjs
import { defineConfig } from 'astro/config';

export default defineConfig({
  output: 'hybrid'
})
```

Note the outputs are:

> `static` - Default: Building a static site to be deployed to any static host. <br />
> `server` - Building an app to be deployed to a host supporting SSR (server-side rendering). <br />
> `hybrid` - Building a static site with a few server-side rendered pages.

```astro:src/pages/index.asto
---
import { connectDb } from "...";

interface Props {
  title: string;
}

const { title } = Astro.props;

export const database = connectDb(
  import.meta.env.DATABASE_URL,
  import.meta.env.DATABASE_KEY,
);

const data = await database.get();
const TitleElementTag = 'h1'
---

<div>
	<TitleElementTag class="font-bold" data-test-id="items-header">
		{title}
	</TitleElementTag>
	<ul>
		{data.map(item => (<li>{item}</li>))}
	</ul>
</div>
```

There's also a bit to unpack in the above:

- Top level await
- Typescript support
- Dynamic HTML element tags
- Props passed to child component
- JSX-like support, note `class` instead of `className` and kebab-case instead of camel-case

## Client-Side JavaScript

Out of the box, Astro focuses on static or server side rendering rather than client side, in turn this reduces the amount of JavaScript sent to the client whilst reducing browser paint times, you may even notice that all content is transformed into HTML on build, event markdown and MDX files. However, you'll of course need client side JavaScript for interactive of buttons, search bars, drop downs and more, but this needs to be explicitly set or Astro will not send the required JavaScript.

There are a few options to optimise it as well, let's see what this looks like if had a banner message which we want to have a close button:

```astro:src/pages/index.astro
---
// This is staticly built into the HTML output or server side rendered
// this uses a argument passed in or uses the default, e.g.
// `<Index bannerMessage={Override the banner message} />` 
const {
	bannerMessage = 'This message is brought to you by jbrlloyd.dev'
} = Astro.props;
---

<!doctype html>
<html lang="en">
	<head>...</head>
	<header>...</header>
	<body>

		{bannerMessage && (
			<div id="content-banner">
			  <p>{bannerMessage}</p>
			  <button id="close-content-banner-btn">
				<b>X</b>
			  </button>
			</div>
		)}

	</body>
	<footer>...</footer>
</html>

<!--
	Astro will compile this into your `<head>` with type="module", preventing 
	rendering blocking of HTML and will be deferred + lazy loaded with async.
	We can use `is:inline `directives to opt-out of this optimizations and
	render it in the HTML: `<script is:inline>` or `<script is:global>` to
	not just scope it to this component
-->
<script>
	const closeBtn = document.getElementById('close-content-banner-btn');
	
	if (closeBtn) {
		closeBtn.addEventListener('click', onClick)
	}
	
	function onClick() {
		closeContentBanner()
		closeBtn?.removeEventListener('click', onClick)
	}
	
	function closeContentBanner() {
		const contentBanner = document.getElementById('content-banner');
		
		if (contentBanner)
			contentBanner.style.display = 'none'
	}
</script>
```

## Integrating Other UI Frameworks

Astro offers the ability to plugin integrations to add functionality such as mdx, sitemaps, tailwind and other UI frameworks such as React, Vue, Svelte, Preact, SolidJS, lit and others.
An example of how we'd setup SolidJs with client side JavaScript is as such:

```js:astro.config.mjs
import { defineConfig } from 'astro/config';
import solidJs from '@astrojs/solid-js';

export default defineConfig({
  site: 'https://example.com',
  integrations: [ solidJs(), react(), mdx() ] // <-- Note you can have multiple UI frameworks
});
```

```tsx:src/components/solid/SolidJsCounter.tsx
import { type Component, createSignal } from 'solid-js';

export default const SolidJsCounter : Component = () => {
  const [count, setCount] = createSignal(0);

  return (
    <>
      <p>Count: {count}</p>
      <button onClick={() => setCount(count => count - 1)}>Decrement</button>
      &nbsp;
      <button onClick={() => setCount(count => count + 1)}>Increment</button>
    </>
  )
}
```

We can now import the SolidJS component, however, because we're making use of client side JavaScript, we need to explicitly provide a client directive, or else the client side JS will not be sent by Astro framework:

```astro:src/pages/index.astro
---
// Server side JavaScript
import SolidJsCounter from '../components/solid/SolidJsCounter.tsx';
---
// Without client directive `client:load` no javascript will be sent to the browser
// and therefore the on click will not do anything.
<SolidJsCounter client:load />
```

### Sharing state between UI frameworks

One problem with having the ability of multiple UI frameworks, is sharing state across them, as usually the state managers are language specific. Hence, the Astro recommendation is using [Nano Stores](https://github.com/nanostores/nanostores), which is lightweight (> 1 KB) and framework agnostic.
Let's see how we can create 2 counters in different frameworks which increment and decrement the same state:

```ts:src/stores/countStore.ts
import { atom, map } from 'nanostores';

export const count = atom(0);

export const incrementCount = () => count = count.get() + 1;
export const decrementCount = () => count = count.get() - 1;
```

```tsx:src/components/solid/SolidJsCounter.tsx
import { type Component } from 'solid-js';
import { useStore } from '@nanostores/solid';

import { count, incrementCount, decrementCount } from '../../sores/countStore';

export default const SolidJsCounter : Component = () => {
  const $count = useStore(count);

  return (
    <>
      <p>Count: {$count}</p>
      <button onClick={() => decrementCount()}>Decrement</button>
      &nbsp;
      <button onClick={() => incrementCount()}>Increment</button>
    </>
  )
}
```

```tsx:src/components/react/ReactCounter.tsx
import { type FunctionComponent } from 'react';
import { useStore } from '@nanostores/react';

import { count, incrementCount, decrementCount } from '../../sores/countStore';

export default const ReactCounter : FunctionComponent = () => {
  const $count = useStore(count);

  return (
    <>
      <p>Count: {$count}</p>
      <button onClick={() => decrementCount()}>Decrement</button>
      &nbsp;
      <button onClick={() => incrementCount()}>Increment</button>
    </>
  )
}
```

```astro:src/pages/index.astro
---
import SolidJsCounter from '../components/solid/SolidJsCounter.tsx';
import ReactCounter from '../components/react/ReactCounter.tsx';
---
<>
	<SolidJsCounter client:only="solid-js" />
	<ReactCounter client:only="react" />
</>
```

## SSR Adaptors

Astro is largely designed for static sites, where it the entire site gets compiled to HTML and CSS, served from a file storage with a web server like nginx or apache serving the files.
However, we make use of server-side rendering (SSR) through one of the following official adaptors:

- CloudFlare
- Netlify
- Vercel
- Node
- And others such as: Deno Deploy, GitHub Pages, AWS, Firebase, Azure, Google Cloud, Heroku + more

Note that node will allow us to host our site with SSR ourselves through most self-hosting mechanisms such as using containers. Each adaptor has different configuration and setup, but all require setting the Astro configuration to `output` a server side capability.
Let's hone in on CloudFlare adapter, first we have to install the adapter into our Astro project:

```bash
> pnpm astro add cloudflare
> pnpm add @astrojs/cloudflare
```

```js:astro.config.mjs
import { defineConfig } from 'astro/config';
import cloudflare from '@astrojs/cloudflare';

export default defineConfig({
  output: 'hybrid', // or full server side with 'server'
  adapter: cloudflare(),
});
```

After enabling CloudFlare (CF) adaptor functionality, we can create a CF pages site and connect it to our repository for automatic deployment. Some functionality between CloudFlare and Astro may not be compatible, allowing the site to work locally when using:
`astro check && astro build && astro build`
but not working when deploying to CF Pages. So the best way to ensure your site will work in CF locally is to use CF Pages emulator via the CF CLI `wrangler`.
Install this and preview:

```bash
> npm install -g wrangler
> wrangler login
> pnpm add wrangler --save-dev
```

We can also wire this up in our project's CLI, note that Astro will compile files into `dist/` directory as it's build output:

```json:package.json
{
	// ...,
	"scripts": {
		"build": "wrangler types && astro check && astro build",
		"preview:cf": "pnpm run build && wrangler pages dev ./dist",
		//...
	},
	//...
}
```

`wrangler pages dev ./dist` will emulate a CF page worker using the Astro build output as the root.

## Conclusion

